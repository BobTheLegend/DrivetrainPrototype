// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import frc.robot.Robot;
import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;

import com.ctre.phoenix.motorcontrol.InvertType;
import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.motorcontrol.TalonFXFeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.TalonFX;
import com.ctre.phoenix.motorcontrol.can.TalonFXConfiguration;
import com.kauailabs.navx.frc.AHRS;
import com.revrobotics.CANEncoder;
import com.revrobotics.CANPIDController;
import com.revrobotics.CANSparkMax;
import com.revrobotics.ControlType;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Joystick;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Drivetrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    CANSparkMax leftMotor1;
    CANSparkMax leftMotor2;
    CANPIDController leftPID;
    CANEncoder leftEncoder;

    CANSparkMax rightMotor1;
    CANSparkMax rightMotor2;
    CANPIDController rightPID;
    CANEncoder rightEncoder;
    
    double kP = 5e-5;
    double kI = 1e-6;
    double kD = 0;
    double kF = 0;
    double speed = 1.0;
    double maxRpm = 6000.0;
    double minOutput = -1;
    double maxOutput = 1;

    double maxVel = 3000;
    double minVel = 0;
    double maxAcc = 2000;
    int smartMotionSlot = 0;
 

    double Ldeadband = .15;
    double Rdeadband = .15;


    

    


    public Drivetrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    leftMotor1 = new CANSparkMax(2, MotorType.kBrushless);
    leftMotor1.setInverted(true);
    leftMotor2 = new CANSparkMax(3, MotorType.kBrushless);
    leftMotor2.follow(leftMotor1);
    leftEncoder = leftMotor1.getEncoder();
    leftEncoder.setPositionConversionFactor(0.25);
    leftPID = leftMotor1.getPIDController();
    leftPID.setOutputRange(minOutput, maxOutput);
    leftPID.setSmartMotionMaxVelocity(maxVel, smartMotionSlot);
    leftPID.setSmartMotionMinOutputVelocity(minVel, smartMotionSlot);
    leftPID.setSmartMotionMaxAccel(maxAcc, smartMotionSlot);
    
    
    
    rightMotor1 = new CANSparkMax(4, MotorType.kBrushless);
    rightMotor2 = new CANSparkMax(5, MotorType.kBrushless);
    rightMotor2.follow(rightMotor1);
    rightEncoder = rightMotor1.getEncoder();
    rightEncoder.setPositionConversionFactor(0.25);
    rightPID = rightMotor1.getPIDController();
    rightPID.setOutputRange(minOutput, maxOutput); 
    rightPID.setSmartMotionMaxVelocity(maxVel, smartMotionSlot);
    rightPID.setSmartMotionMinOutputVelocity(minVel, smartMotionSlot);
    rightPID.setSmartMotionMaxAccel(maxAcc, smartMotionSlot);
    

    leftPID.setP(kP);
    leftPID.setI(kI);
    leftPID.setD(kD);
    leftPID.setFF(kF);
    

    rightPID.setP(kP);
    rightPID.setI(kI);
    rightPID.setD(kD);
    rightPID.setFF(kF);

    //imu = new ADIS16448_IMU();
    


    }

    @Override
    public void initDefaultCommand() {

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
        //setDefaultCommand(new VelocityDrive());
        setDefaultCommand(new VelocityDrive());
    }

    @Override
    public void periodic() {

        if(Robot.oi.getleftJoy().getTrigger()||Robot.oi.getrightJoy().getTrigger()){
            speed = 0.125;
        }
        else{
            speed = .5;
        }

        //In one println print out pitch roll yaw XAccel YAccel ZAccel magnometer etc

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // Put methods for controlling this subsystem
    // here. Call these from Commands.


    // Converts joystick input adjusted for deadband to current for the motor
    

    // Converts joystick input adjusted to a RPM for the Falcon's PIDF loop to aim for
    public void velocityDrive(Joystick left, Joystick right){
        double leftSetpoint = 0;
        double rightSetpoint = 0;
        double leftPos = left.getY();
        double rightPos = right.getY();
        rightSetpoint = 0.;
        leftSetpoint  = 0.;
        //rightSetpoint = rightPos * maxRpm * speed * 0.5;
        //leftSetpoint = leftPos * maxRpm * speed * 0.5;
        if(Math.abs(leftPos) >= Ldeadband){
            leftSetpoint = ((leftPos - Ldeadband) * maxRpm * speed);
            //leftSetpoint -= kTurn;
        }
        if(Math.abs(rightPos) >= Rdeadband){
            rightSetpoint = ((rightPos - Rdeadband) * maxRpm * speed);
            //rightSetpoint += kTurn;
        }
        
        /*if(badIdea){
            leftSetpoint = -maxRpm;
            rightSetpoint = -maxRpm;
        }*/



        leftPID.setReference(leftSetpoint, ControlType.kVelocity);
        rightPID.setReference(rightSetpoint, ControlType.kVelocity);
       
    }

    public void dumbDrive(Joystick left, Joystick right){
        leftMotor1.set(left.getY());
        rightMotor1.set(right.getY());
    }


    // Stops motor usually used after the drive command ends to prevent shenanigans
    public void stop() {
        leftMotor1.set(0);
        rightMotor1.set(0);
    }

    //Calculates the motor power to use based on a given deadband and joystick input from -1 to 1
    //Prevents spikes in motor power by calculating the line to use where 0 is the deadband and 1 is the max
  
}

